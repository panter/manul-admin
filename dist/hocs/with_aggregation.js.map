{"version":3,"sources":["../../src/hocs/with_aggregation.js"],"names":["composer","props","onData","aggregationName","aggregations","aggregation","Error","aggregate","aggregateComposer","aggregationProps","allAggregationProps","griddleLocal","isAggregation","e","p","docsAggregated","docs","exportCurrentSearchAsCsv","exportCsvFromLocalDocs","exportArgs","type"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA;;AAIA;;;;;;AACA;;;AAGO,IAAMA,WAAW,SAAXA,QAAW;AAAA,SAAM,UAACC,KAAD,EAAQC,MAAR,EAAmB;AAAA,QACvCC,eADuC,GACLF,KADK,CACvCE,eADuC;AAAA,QACtBC,YADsB,GACLH,KADK,CACtBG,YADsB;;AAE/C,QAAMC,cAAc,mBAAIF,eAAJ,EAAqBC,YAArB,CAApB;AACA,QAAI,CAACC,WAAL,EAAkB;AAChBH,aAAO,IAAII,KAAJ,yBAAgCH,eAAhC,CAAP;AACD,KAFD,MAEO;AAAA,UACGI,SADH,GACyDF,WADzD,CACGE,SADH;AAAA,UACcC,iBADd,GACyDH,WADzD,CACcG,iBADd;AAAA,UACoCC,gBADpC,0CACyDJ,WADzD;;AAEL,UAAMK,iDACDD,gBADC;AAEJE,sBAAc,IAFV;AAGJC,uBAAe;AAHX,QAAN;AAKA,UAAIJ,iBAAJ,EAAuB;AACrBA,0BAAkBP,KAAlB,EAAyB,UAACY,CAAD,EAAIC,CAAJ;AAAA,iBACvBZ,OAAOW,CAAP,6BAAeH,mBAAf,EAAuCI,CAAvC,EADuB;AAAA,SAAzB;AAGD,OAJD,MAIO,IAAIP,SAAJ,EAAe;AACpB,YAAMQ,iBAAiBR,UAAUN,MAAMe,IAAhB,EAAsBf,KAAtB,CAAvB;AACAC,eAAO,IAAP;AACEc,gBAAMD;AADR,WAEKL,mBAFL;AAID,OANM,MAMA;AACLR,eAAO,IAAII,KAAJ,CAAU,+CAAV,CAAP;AACD;AACF;AACF,GA1BuB;AAAA,CAAjB;;;;kBA4BQ;AAAA,SACb,+BACE,4BAAa;AACX;AACAW,8BAA0B;AAAA,UAAGD,IAAH,QAAGA,IAAH;AAAA,UAASE,sBAAT,QAASA,sBAAT;AAAA,aAAsC,YAE3D;AAAA,0CADAC,UACA;AADAA,oBACA;AAAA;;AACHD,iDAAuBF,IAAvB,SAAgCG,UAAhC;AACD,OAJyB;AAAA;AAFf,GAAb,CADF,EASE,kCAAmBnB,SAASoB,IAAT,CAAnB,CATF,CADa;AAAA,C","file":"with_aggregation.js","sourcesContent":["import { composeAll } from '@storybook/react-komposer';\nimport { get } from 'lodash/fp';\nimport { withHandlers } from 'recompose';\n\nimport composeWithTracker from '../utils/composeWithTracker';\n/**\n * this does a \"soft\" aggregation on the client\n */\nexport const composer = () => (props, onData) => {\n  const { aggregationName, aggregations } = props;\n  const aggregation = get(aggregationName)(aggregations);\n  if (!aggregation) {\n    onData(new Error(`unkown aggregation:${aggregationName}`));\n  } else {\n    const { aggregate, aggregateComposer, ...aggregationProps } = aggregation;\n    const allAggregationProps = {\n      ...aggregationProps,\n      griddleLocal: true,\n      isAggregation: true\n    };\n    if (aggregateComposer) {\n      aggregateComposer(props, (e, p) =>\n        onData(e, { ...allAggregationProps, ...p })\n      );\n    } else if (aggregate) {\n      const docsAggregated = aggregate(props.docs, props);\n      onData(null, {\n        docs: docsAggregated,\n        ...allAggregationProps\n      });\n    } else {\n      onData(new Error('specify either aggregate or aggregateComposer'));\n    }\n  }\n};\n\nexport default type =>\n  composeAll(\n    withHandlers({\n      // overwrite\n      exportCurrentSearchAsCsv: ({ docs, exportCsvFromLocalDocs }) => (\n        ...exportArgs\n      ) => {\n        exportCsvFromLocalDocs(docs, ...exportArgs);\n      }\n    }),\n    composeWithTracker(composer(type))\n  );\n"]}