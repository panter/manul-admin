{"version":3,"sources":["../../../src/initMethods/getListResult/index.js"],"names":["DEBUG","logObject","replacer","key","value","RegExp","toString","console","log","obj","COUNT_PRESERVING_STAGES","addCount","lastCountChangingStage","stages","stage","find","includes","slice","$count","getPipeline","context","collectionConfig","listOptions","countOnly","Meteor","filter","searchTerm","sortProperties","pageProperties","searchFields","filterToBaseQuery","textIndex","aggregation","useTextIndex","isServer","Boolean","baseQuery","queryOptions","aggregationOptions","basePipeline","$match","sortPipeline","sort","$sort","limit","$limit","skip","$skip","postSort","getCount","getDocuments","time","pipeline","docs","collection","undefined","timeEnd","length","count","pageSize","currentPage","result"],"mappings":"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","file":"index.js","sourcesContent":["// @flow\nimport isEmpty from 'lodash/isEmpty';\nimport isFunction from 'lodash/isFunction';\nimport findLastIndex from 'lodash/findLastIndex';\nimport type {\n  MethodsContextT,\n  CollectionConfigT,\n  ListOptionsT\n} from '../../types';\nimport mongoAggregation from '../../utils/mongoAggregation';\nimport { createQuery, createQueryOptions } from '../../utils/query_utils';\n\nconst DEBUG = true;\n\nconst logObject = obj => {\n  function replacer(key, value) {\n    if (value instanceof RegExp) return `__REGEXP ${value.toString()}`;\n    return value;\n  }\n  console.log(JSON.stringify(obj, replacer, 2));\n};\n\nconst COUNT_PRESERVING_STAGES = ['$addFields', '$project', '$lookup', '$sort'];\n/**\n * intelligently add the $count stage after the last stage that influences the count\n * if no such stage is given, add only the $count stage\n * @param {Array} stages\n */\nconst addCount = stages => {\n  const lastCountChangingStage = findLastIndex(stages, stage =>\n    Object.keys(stage).find(key => !COUNT_PRESERVING_STAGES.includes(key))\n  );\n  return [...stages.slice(0, lastCountChangingStage + 1), { $count: 'count' }];\n};\n\nconst getPipeline = ({\n  context,\n  collectionConfig,\n  listOptions,\n  countOnly = false\n}: {\n  context: MethodsContextT,\n  collectionConfig: CollectionConfigT,\n  listOptions: ListOptionsT,\n  countOnly?: boolean\n}) => {\n  const { Meteor } = context;\n  const { filter, searchTerm, sortProperties, pageProperties } = listOptions;\n  const {\n    searchFields,\n    filterToBaseQuery,\n    textIndex,\n    aggregation\n  } = collectionConfig;\n  const useTextIndex = Meteor.isServer && Boolean(textIndex);\n  const baseQuery = createQuery({\n    filter,\n    searchFields,\n    searchTerm,\n    filterToBaseQuery,\n    useTextIndex\n  });\n\n  const queryOptions = createQueryOptions({\n    sortProperties,\n    pageProperties\n  });\n\n  if (DEBUG) logObject({ searchTerm, baseQuery, queryOptions });\n  /* eslint no-nested-ternary: 0*/\n\n  const aggregationOptions =\n    aggregation && isFunction(aggregation)\n      ? aggregation({\n          searchTerm,\n          filter,\n          collectionConfig,\n          listOptions,\n          countOnly\n        })\n      : aggregation;\n\n  const basePipeline = [{ $match: baseQuery }];\n  if (countOnly) {\n    return [\n      ...basePipeline,\n      ...(aggregationOptions && aggregationOptions.stages\n        ? addCount(aggregationOptions.stages)\n        : [{ $count: 'count' }])\n    ];\n  }\n  const sortPipeline = [\n    ...(!isEmpty(queryOptions.sort) ? [{ $sort: queryOptions.sort }] : []),\n    ...(queryOptions.limit\n      ? [{ $limit: queryOptions.limit + (queryOptions.skip || 0) }]\n      : []),\n    { $skip: queryOptions.skip || 0 }\n  ];\n\n  return [\n    ...basePipeline,\n    ...(aggregationOptions && !aggregationOptions.postSort ? sortPipeline : []),\n    ...(aggregationOptions ? aggregationOptions.stages : []),\n    ...(!aggregationOptions || aggregationOptions.postSort ? sortPipeline : [])\n  ];\n};\n\n/* eslint import/prefer-default-export: 0 */\nexport default ({\n  context,\n  collectionConfig,\n  listOptions,\n  getCount = true,\n  getDocuments = true\n}: {\n  context: MethodsContextT,\n\n  collectionConfig: CollectionConfigT,\n  listOptions: ListOptionsT,\n  getCount?: boolean,\n  getDocuments?: boolean\n}) => {\n  if (DEBUG) console.log('listOptions', listOptions);\n  if (DEBUG) console.time('docs aggregation');\n  const pipeline = getPipeline({\n    context,\n    collectionConfig,\n    listOptions\n  });\n  if (DEBUG) logObject(pipeline);\n\n  const docs = getDocuments\n    ? mongoAggregation(context, collectionConfig.collection, pipeline)\n    : undefined;\n  if (DEBUG) console.timeEnd('docs aggregation');\n  if (DEBUG) console.log('num docs', docs && docs.length);\n  /*\n  if (DEBUG) console.time('docs');\n  const docs = getDocuments\n    ? collectionConfig.collection.find(query, queryOptions).fetch()\n    : undefined;\n  if (DEBUG) console.timeEnd('docs');\n\n  if (DEBUG) console.time('count');\n  const count = getCount\n    ? collectionConfig.collection.find(query).count()\n    : undefined;\n  if (DEBUG) console.timeEnd('count');\n\n    */\n  if (DEBUG) console.time('countAggregation');\n  let count = 0;\n\n  if (getCount) {\n    const { pageProperties } = listOptions;\n\n    if (docs && pageProperties && docs.length < pageProperties.pageSize) {\n      count =\n        docs.length +\n        (pageProperties.currentPage - 1) * pageProperties.pageSize;\n    } else {\n      const result = mongoAggregation(\n        context,\n        collectionConfig.collection,\n        getPipeline({\n          context,\n          collectionConfig,\n          listOptions,\n          countOnly: true\n        })\n      );\n      count = result[0] ? result[0].count : 0;\n    }\n  }\n\n  if (DEBUG) console.timeEnd('countAggregation');\n  console.log('countAggregation', count);\n  return { docs, count };\n};\n"]}